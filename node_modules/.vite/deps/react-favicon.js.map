{
  "version": 3,
  "sources": ["../../react-favicon/src/index.js"],
  "sourcesContent": ["'use strict'\n\nconst React = require('react')\nconst PropTypes = require('prop-types')\n\nconst DefaultCanvasSize = 16\nconst linkElements = []\n\nconst drawAlert = (context, { fillColor, text, textColor, canvasSize }) => {\n  // Allow same looking padding over differents iconSizes\n  const Padding = canvasSize / 5;\n  // Allow readable text across differnts iconSizes\n  context.font = `bold ${canvasSize - (Padding * 2)}px arial`;\n\n  const w = Math.min(\n    // Take the text with if it's smaller than available space (eg: '2')\n    context.measureText(text).width,\n    // Or take the maximum size we'll force our text to fit in anyway (eg: '1000000')\n    canvasSize - Padding) + Padding\n\n  const x = canvasSize - w\n  const y = canvasSize / 2 - Padding\n  const h = Padding + canvasSize / 2\n  const r = Math.min(w / 2, h / 2)\n\n  context.beginPath()\n  context.moveTo(x + r, y)\n  context.arcTo(x + w, y, x + w, y + h, r)\n  context.arcTo(x + w, y + h, x, y + h, r)\n  context.arcTo(x, y + h, x, y, r)\n  context.arcTo(x, y, x + w, y, r)\n  context.closePath()\n  context.fillStyle = fillColor\n  context.fill()\n  context.fillStyle = textColor\n  context.textBaseline = 'bottom'\n  context.textAlign = 'right'\n  context.fillText(\n    text,\n    canvasSize - Padding / 2,\n    canvasSize,\n    // This will prevent the text from going outside the favicon, instead it'll squeeze his with to fit in\n    canvasSize - Padding)\n}\n\nfunction drawIcon({\n  alertCount,\n  alertFillColor,\n  alertTextColor,\n  callback,\n  renderOverlay,\n  url: src,\n  canvasSize,\n}) {\n  const img = document.createElement('img')\n  img.crossOrigin = 'Anonymous'\n  img.onload = function () {\n    const canvas = document.createElement('canvas')\n    canvas.width = canvasSize;\n    canvas.height = canvasSize;\n\n    const context = canvas.getContext('2d')\n    context.clearRect(0, 0, img.width, img.height)\n    context.drawImage(img, 0, 0, canvas.width, canvas.height)\n\n    if (alertCount) {\n      drawAlert(context, {\n        fillColor: alertFillColor,\n        textColor: alertTextColor,\n        text: alertCount,\n        canvasSize,\n      })\n    }\n\n    if (renderOverlay) {\n      renderOverlay(canvas, context)\n    }\n    callback(context.canvas.toDataURL())\n  }\n  img.src = src\n}\n\nclass Favicon extends React.Component {\n  static displayName = 'Favicon'\n\n  static mountedInstances = []\n\n  static getActiveInstance() {\n    return Favicon.mountedInstances[Favicon.mountedInstances.length - 1]\n  }\n\n  static draw() {\n    if (typeof document === 'undefined') return\n\n    var activeInstance = Favicon.getActiveInstance()\n    if (linkElements.length === 0) {\n      var head = document.getElementsByTagName('head')[0]\n\n      const linkEl = document.createElement('link')\n      linkEl.type = 'image/x-icon'\n      linkEl.rel = 'icon'\n\n      const linkApple = document.createElement('link')\n      linkApple.rel = 'apple-touch-icon'\n\n      linkElements.push(linkEl, linkApple)\n\n      // remove existing favicons\n      var links = head.getElementsByTagName('link')\n      for (var i = links.length; --i >= 0; ) {\n        if (\n          /\\bicon\\b/i.test(links[i].getAttribute('rel')) &&\n          !activeInstance.props.keepIconLink(links[i])\n        ) {\n          head.removeChild(links[i])\n        }\n      }\n\n      linkElements.forEach((el) => head.appendChild(el))\n    }\n\n    var currentUrl\n\n    if (activeInstance.props.url instanceof Array) {\n      currentUrl = activeInstance.props.url[activeInstance.state.animationIndex]\n    } else {\n      currentUrl = activeInstance.props.url\n    }\n\n    if (activeInstance.props.alertCount || activeInstance.props.renderOverlay) {\n      drawIcon({\n        alertCount: activeInstance.props.alertCount,\n        alertFillColor: activeInstance.props.alertFillColor,\n        alertTextColor: activeInstance.props.alertTextColor,\n        callback: (url) => {\n          linkElements.forEach((el) => el.href = url)\n        },\n        renderOverlay: activeInstance.props.renderOverlay,\n        url: currentUrl,\n        canvasSize: activeInstance.props.iconSize\n      })\n    } else {\n      linkElements.forEach((el) => el.href = currentUrl)\n    }\n  }\n\n  static update() {\n    if (typeof document === 'undefined') return\n\n    var activeInstance = Favicon.getActiveInstance()\n    var isAnimated =\n      activeInstance.props.url instanceof Array && activeInstance.props.animated\n\n    // clear any running animations\n    var intervalId = null\n    clearInterval(activeInstance.state.animationLoop)\n\n    if (isAnimated) {\n      var animateFavicon = function animateFavicon() {\n        var nextAnimationIndex =\n          (activeInstance.state.animationIndex + 1) %\n          activeInstance.props.url.length\n        Favicon.draw()\n        activeInstance.setState({ animationIndex: nextAnimationIndex })\n      }\n      intervalId = setInterval(\n        animateFavicon,\n        activeInstance.props.animationDelay\n      )\n      animateFavicon()\n    } else {\n      Favicon.draw()\n    }\n\n    activeInstance.setState({ animationLoop: intervalId })\n  }\n\n  state = {\n    animationIndex: 0,\n    animationLoop: null,\n    animationRunning: false,\n  }\n\n  componentDidMount() {\n    Favicon.mountedInstances.push(this)\n    Favicon.update()\n  }\n\n  componentWillUnmount() {\n    var activeInstance = Favicon.getActiveInstance()\n    clearInterval(activeInstance.state.animationLoop)\n  }\n\n  componentDidUpdate(prevProps) {\n    if (\n      prevProps.url === this.props.url &&\n      prevProps.animated === this.props.animated &&\n      prevProps.alertCount === this.props.alertCount &&\n      prevProps.alertFillColor === this.props.alertFillColor &&\n      prevProps.alertTextColor === this.props.alertTextColor &&\n      prevProps.renderOverlay === this.props.renderOverlay &&\n      prevProps.keepIconLink === this.props.keepIconLink &&\n      prevProps.iconSize === this.props.iconSize\n    )\n      return\n\n    Favicon.update()\n  }\n\n  render() {\n    return null\n  }\n}\n\nFavicon.defaultProps = {\n  iconSize: DefaultCanvasSize,\n  alertCount: null,\n  alertFillColor: 'red',\n  alertTextColor: 'white',\n  animated: true,\n  animationDelay: 500,\n  keepIconLink: () => false,\n  renderOverlay: null,\n  url: null,\n}\n\nFavicon.propTypes = {\n  iconSize: PropTypes.number,\n  alertCount: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  alertFillColor: PropTypes.string,\n  alertTextColor: PropTypes.string,\n  animated: PropTypes.bool,\n  animationDelay: PropTypes.number,\n  keepIconLink: PropTypes.func,\n  renderOverlay: PropTypes.func,\n  url: PropTypes.oneOfType([\n    PropTypes.arrayOf(PropTypes.string),\n    PropTypes.string,\n  ]).isRequired,\n}\n\nmodule.exports = Favicon\n"],
  "mappings": "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",
  "names": ["React", "require", "PropTypes", "DefaultCanvasSize", "linkElements", "drawAlert", "context", "fillColor", "text", "textColor", "canvasSize", "Padding", "font", "w", "Math", "min", "measureText", "width", "x", "y", "h", "r", "beginPath", "moveTo", "arcTo", "closePath", "fillStyle", "fill", "textBaseline", "textAlign", "fillText", "drawIcon", "alertCount", "alertFillColor", "alertTextColor", "callback", "renderOverlay", "src", "url", "img", "document", "createElement", "crossOrigin", "onload", "canvas", "height", "getContext", "clearRect", "drawImage", "toDataURL", "Favicon", "state", "animationIndex", "animationLoop", "animationRunning", "getActiveInstance", "mountedInstances", "length", "draw", "activeInstance", "head", "getElementsByTagName", "linkEl", "type", "rel", "linkApple", "push", "links", "i", "test", "getAttribute", "props", "keepIconLink", "removeChild", "forEach", "el", "appendChild", "currentUrl", "Array", "href", "iconSize", "update", "isAnimated", "animated", "intervalId", "clearInterval", "animateFavicon", "nextAnimationIndex", "setState", "setInterval", "animationDelay", "componentDidMount", "componentWillUnmount", "componentDidUpdate", "prevProps", "render", "Component", "displayName", "defaultProps", "propTypes", "number", "oneOfType", "string", "bool", "func", "arrayOf", "isRequired", "module", "exports"]
}
