import {
  getOverlayDirection
} from "./chunk-2W7MLACI.js";
import {
  Fade_default,
  hasClass,
  safeFindDOMNode,
  useWaitForDOMRef
} from "./chunk-J22ZK4ZK.js";
import {
  getRefTarget,
  mergeOptionsWithPopperConfig,
  useClickOutside_default,
  usePopper_default
} from "./chunk-2NHBBVH7.js";
import {
  useCallbackRef
} from "./chunk-5RLHEDJE.js";
import {
  listen_default,
  ownerDocument
} from "./chunk-TBSI5A23.js";
import {
  useEventCallback,
  useIsomorphicEffect_default,
  useMergedRefs_default
} from "./chunk-VKC2C4BX.js";
import {
  createWithBsPrefix
} from "./chunk-4T6T47MF.js";
import {
  require_react_dom
} from "./chunk-XY35XOXX.js";
import {
  require_classnames,
  useBootstrapPrefix,
  useIsRTL
} from "./chunk-EUOH2COW.js";
import {
  require_jsx_runtime
} from "./chunk-ERD5GGZY.js";
import {
  __toESM,
  require_react
} from "./chunk-C3URVCCN.js";

// node_modules/react-bootstrap/esm/Overlay.js
var React3 = __toESM(require_react());
var import_react4 = __toESM(require_react());
var import_classnames2 = __toESM(require_classnames());

// node_modules/@restart/ui/esm/Overlay.js
var React = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var import_react2 = __toESM(require_react());

// node_modules/@restart/ui/esm/useRootClose.js
var import_react = __toESM(require_react());
var escapeKeyCode = 27;
var noop = () => {
};
function useRootClose(ref, onRootClose, {
  disabled,
  clickTrigger
} = {}) {
  const onClose = onRootClose || noop;
  useClickOutside_default(ref, onClose, {
    disabled,
    clickTrigger
  });
  const handleKeyUp = useEventCallback((e) => {
    if (e.keyCode === escapeKeyCode) {
      onClose(e);
    }
  });
  (0, import_react.useEffect)(() => {
    if (disabled || ref == null)
      return void 0;
    const doc = ownerDocument(getRefTarget(ref));
    let currentEvent = (doc.defaultView || window).event;
    const removeKeyupListener = listen_default(doc, "keyup", (e) => {
      if (e === currentEvent) {
        currentEvent = void 0;
        return;
      }
      handleKeyUp(e);
    });
    return () => {
      removeKeyupListener();
    };
  }, [ref, disabled, handleKeyUp]);
}
var useRootClose_default = useRootClose;

// node_modules/@restart/ui/esm/Overlay.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var Overlay = React.forwardRef((props, outerRef) => {
  const {
    flip,
    offset,
    placement,
    containerPadding,
    popperConfig = {},
    transition: Transition
  } = props;
  const [rootElement, attachRef] = useCallbackRef();
  const [arrowElement, attachArrowRef] = useCallbackRef();
  const mergedRef = useMergedRefs_default(attachRef, outerRef);
  const container = useWaitForDOMRef(props.container);
  const target = useWaitForDOMRef(props.target);
  const [exited, setExited] = (0, import_react2.useState)(!props.show);
  const popper = usePopper_default(target, rootElement, mergeOptionsWithPopperConfig({
    placement,
    enableEvents: !!props.show,
    containerPadding: containerPadding || 5,
    flip,
    offset,
    arrowElement,
    popperConfig
  }));
  if (props.show) {
    if (exited)
      setExited(false);
  } else if (!props.transition && !exited) {
    setExited(true);
  }
  const handleHidden = (...args) => {
    setExited(true);
    if (props.onExited) {
      props.onExited(...args);
    }
  };
  const mountOverlay = props.show || Transition && !exited;
  useRootClose_default(rootElement, props.onHide, {
    disabled: !props.rootClose || props.rootCloseDisabled,
    clickTrigger: props.rootCloseEvent
  });
  if (!mountOverlay) {
    return null;
  }
  let child = props.children(Object.assign({}, popper.attributes.popper, {
    style: popper.styles.popper,
    ref: mergedRef
  }), {
    popper,
    placement,
    show: !!props.show,
    arrowProps: Object.assign({}, popper.attributes.arrow, {
      style: popper.styles.arrow,
      ref: attachArrowRef
    })
  });
  if (Transition) {
    const {
      onExit,
      onExiting,
      onEnter,
      onEntering,
      onEntered
    } = props;
    child = (0, import_jsx_runtime.jsx)(Transition, {
      in: props.show,
      appear: true,
      onExit,
      onExiting,
      onExited: handleHidden,
      onEnter,
      onEntering,
      onEntered,
      children: child
    });
  }
  return container ? import_react_dom.default.createPortal(child, container) : null;
});
Overlay.displayName = "Overlay";
var Overlay_default = Overlay;

// node_modules/react-bootstrap/esm/useOverlayOffset.js
var import_react3 = __toESM(require_react());

// node_modules/react-bootstrap/esm/Popover.js
var import_classnames = __toESM(require_classnames());
var React2 = __toESM(require_react());

// node_modules/react-bootstrap/esm/PopoverHeader.js
var PopoverHeader_default = createWithBsPrefix("popover-header");

// node_modules/react-bootstrap/esm/PopoverBody.js
var PopoverBody_default = createWithBsPrefix("popover-body");

// node_modules/react-bootstrap/esm/Popover.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var defaultProps = {
  placement: "right"
};
var Popover = React2.forwardRef(({
  bsPrefix,
  placement,
  className,
  style,
  children,
  body,
  arrowProps,
  popper: _,
  show: _1,
  ...props
}, ref) => {
  const decoratedBsPrefix = useBootstrapPrefix(bsPrefix, "popover");
  const isRTL = useIsRTL();
  const [primaryPlacement] = (placement == null ? void 0 : placement.split("-")) || [];
  const bsDirection = getOverlayDirection(primaryPlacement, isRTL);
  return (0, import_jsx_runtime3.jsxs)("div", {
    ref,
    role: "tooltip",
    style,
    "x-placement": primaryPlacement,
    className: (0, import_classnames.default)(className, decoratedBsPrefix, primaryPlacement && `bs-popover-${bsDirection}`),
    ...props,
    children: [(0, import_jsx_runtime2.jsx)("div", {
      className: "popover-arrow",
      ...arrowProps
    }), body ? (0, import_jsx_runtime2.jsx)(PopoverBody_default, {
      children
    }) : children]
  });
});
Popover.defaultProps = defaultProps;
var Popover_default = Object.assign(Popover, {
  Header: PopoverHeader_default,
  Body: PopoverBody_default,
  POPPER_OFFSET: [0, 8]
});

// node_modules/react-bootstrap/esm/useOverlayOffset.js
function useOverlayOffset(customOffset) {
  const overlayRef = (0, import_react3.useRef)(null);
  const popoverClass = useBootstrapPrefix(void 0, "popover");
  const offset = (0, import_react3.useMemo)(() => ({
    name: "offset",
    options: {
      offset: () => {
        if (overlayRef.current && hasClass(overlayRef.current, popoverClass)) {
          return customOffset || Popover_default.POPPER_OFFSET;
        }
        return customOffset || [0, 0];
      }
    }
  }), [customOffset, popoverClass]);
  return [overlayRef, [offset]];
}

// node_modules/react-bootstrap/esm/Overlay.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var defaultProps2 = {
  transition: Fade_default,
  rootClose: false,
  show: false,
  placement: "top"
};
function wrapRefs(props, arrowProps) {
  const {
    ref
  } = props;
  const {
    ref: aRef
  } = arrowProps;
  props.ref = ref.__wrapped || (ref.__wrapped = (r) => ref(safeFindDOMNode(r)));
  arrowProps.ref = aRef.__wrapped || (aRef.__wrapped = (r) => aRef(safeFindDOMNode(r)));
}
var Overlay2 = React3.forwardRef(({
  children: overlay,
  transition,
  popperConfig = {},
  ...outerProps
}, outerRef) => {
  const popperRef = (0, import_react4.useRef)({});
  const [firstRenderedState, setFirstRenderedState] = useCallbackRef();
  const [ref, modifiers] = useOverlayOffset(outerProps.offset);
  const mergedRef = useMergedRefs_default(outerRef, ref);
  const actualTransition = transition === true ? Fade_default : transition || void 0;
  const handleFirstUpdate = useEventCallback((state) => {
    setFirstRenderedState(state);
    popperConfig == null ? void 0 : popperConfig.onFirstUpdate == null ? void 0 : popperConfig.onFirstUpdate(state);
  });
  useIsomorphicEffect_default(() => {
    if (firstRenderedState) {
      popperRef.current.scheduleUpdate == null ? void 0 : popperRef.current.scheduleUpdate();
    }
  }, [firstRenderedState]);
  return (0, import_jsx_runtime4.jsx)(Overlay_default, {
    ...outerProps,
    ref: mergedRef,
    popperConfig: {
      ...popperConfig,
      modifiers: modifiers.concat(popperConfig.modifiers || []),
      onFirstUpdate: handleFirstUpdate
    },
    transition: actualTransition,
    children: (overlayProps, {
      arrowProps,
      popper: popperObj,
      show
    }) => {
      var _popperObj$state, _popperObj$state$modi;
      wrapRefs(overlayProps, arrowProps);
      const updatedPlacement = popperObj == null ? void 0 : popperObj.placement;
      const popper = Object.assign(popperRef.current, {
        state: popperObj == null ? void 0 : popperObj.state,
        scheduleUpdate: popperObj == null ? void 0 : popperObj.update,
        placement: updatedPlacement,
        outOfBoundaries: (popperObj == null ? void 0 : (_popperObj$state = popperObj.state) == null ? void 0 : (_popperObj$state$modi = _popperObj$state.modifiersData.hide) == null ? void 0 : _popperObj$state$modi.isReferenceHidden) || false
      });
      if (typeof overlay === "function")
        return overlay({
          ...overlayProps,
          placement: updatedPlacement,
          show,
          ...!transition && show && {
            className: "show"
          },
          popper,
          arrowProps
        });
      return React3.cloneElement(overlay, {
        ...overlayProps,
        placement: updatedPlacement,
        arrowProps,
        popper,
        className: (0, import_classnames2.default)(overlay.props.className, !transition && show && "show"),
        style: {
          ...overlay.props.style,
          ...overlayProps.style
        }
      });
    }
  });
});
Overlay2.displayName = "Overlay";
Overlay2.defaultProps = defaultProps2;
var Overlay_default2 = Overlay2;

export {
  Overlay_default2 as Overlay_default
};
//# sourceMappingURL=chunk-RUTFJEED.js.map
